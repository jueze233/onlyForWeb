export class PerformanceMonitor{constructor(){this.metrics={conversionTime:[],cacheHitRate:0,memoryUsage:[],apiResponseTime:[]},this.startMonitoring()}startMonitoring(){performance.memory&&setInterval(()=>{this.metrics.memoryUsage.push({timestamp:Date.now(),used:performance.memory.usedJSHeapSize,total:performance.memory.totalJSHeapSize}),this.metrics.memoryUsage.length>100&&this.metrics.memoryUsage.shift()},5e3)}measureTime(e,t){return async(...r)=>{let i=performance.now();try{let s=await e(...r),o=performance.now()-i;return this.recordMetric(t,o),console.log(`[Performance] ${t}: ${o.toFixed(2)}ms`),s}catch(m){let n=performance.now()-i;throw this.recordMetric(t,n),m}}}recordMetric(e,t){this.metrics[e]||(this.metrics[e]=[]),this.metrics[e].push({timestamp:Date.now(),value:t}),this.metrics[e].length>100&&this.metrics[e].shift()}getReport(){let e={};return Object.keys(this.metrics).forEach(t=>{let r=this.metrics[t];if(Array.isArray(r)&&r.length>0){let i=r.map(e=>e.value||0);e[t]={average:i.reduce((e,t)=>e+t,0)/i.length,min:Math.min(...i),max:Math.max(...i),count:i.length}}}),e}exportData(){let e={timestamp:new Date().toISOString(),metrics:this.metrics,report:this.getReport()},t=new Blob([JSON.stringify(e,null,2)],{type:"application/json"}),r=URL.createObjectURL(t),i=document.createElement("a");i.href=r,i.download=`performance_${Date.now()}.json`,i.click(),URL.revokeObjectURL(r)}}export const perfMonitor=new PerformanceMonitor;